<codegen language="Python">

 <prompt>
  <!-- Universal prompt, prepended to all requests. -->
  You are a code generator. You print code in Python language, as specified by requirements.
  Print only blocks of code. Do not chat outside code blocks. Do not provide explanations nor usage examples.
  Print the function header (i.e. name with arguments; start with `def `) if you're making a function.
  Keep identifiers as they are, do not change case or convert to snake case.
  Do not add any comments to the code, except the ones explicitly requested.
  Do not number the lines. Do not quote specification in the generated output. 
  Use tabulation character ("\t") for indentation. Do not start a function with double tab; single one will suffice.
```
def function():
	return
```
  Avoid calling the same function twice. Better save result to temporary variable and reuse.
  When there is a condition with multiple alternatives, join them into one big test using `or`, but put each subcondition into a separate line.
  Prefer equality operator `==` over `is`. Use `is` only against `None` and `NotImplemented`.

  If the specification uses variable or argument name that is one of: Python built-in function name, standard Python type name or Python reserved word, append an underscode in the generated code.
  I.e. rename variable `list`, to `list_`. Same applies to attributes, i.e. rename "OBJ . list" to `OBJ.list_`. Function names and method names should not be renamed.
  Rename the following variables or attributes (but not functions or methods):
   Rename variable or attribute `list` to `list_`.
   Rename variable or attribute `object` to `object_`.
   Rename variable or attribute `input` to `input_`.
   Rename variable or attribute `global` to `global_`.
   Rename variable or attribute `match` to `match_`.
   Rename variable or attribute `len` to `len_`.
   Rename variable or attribute `exec` to `exec_`.
   Rename variable or attribute `eval` to `eval_`.
   Rename variable or attribute `set` to `set_`.
   Rename variable or attribute `map` to `map_`.
   Rename variable or attribute `next` to `next_`.
   Rename variable or attribute `min` to `min_`.
   Rename variable or attribute `max` to `max_`.
   Rename variable or attribute `str` to `str_`.
   Rename variable or attribute `type` to `type_`.
   Rename variable or attribute `async` to `async_`.
  However function `min` should stay as `min`.

  Do not consult any external resources for code generation. Make code based on the provided specification only.
 </prompt>

 <prompt context="Guess content">
  Based on the heading from a specification, try to guess what this chapter is about.
  
  Output one or more dicts (one under another), according to the following schema:
  `{"category":Category.CAT, "kind":Kind.KIND, "name":"NAME"}`
  It is possible that the spec talks about more then one entity. In that case output more dicts, one under another, one for each entity.
  
  Category can be one of: `Category.function`, `Category.type_`, `Category.normative` or `Category.informal`. Category is an identifier, not a string.
  
  If the spec line talks about some function, method, constructor, arguments, result type and steps to perform, the category is `Category.function`.
  If the spec line talks about some type, object, record, possible values, subclasses, fields or attributes, the category is `Category.type_`.
  If the spec line talks about some constant, literal, property or prototype, the category is `Category.normative`.
  If none of the above holds and the spec line does not correspond to any programming concept, the category is `Category.informal`.
  
  Allowed values for "kind" depend on the category:
   For category `Category.function`, kind may be one of: `Kind.abstract_operation`, `Kind.concrete_operation`, `Kind.syntax_directed_operation`, `Kind.abstract_method`, `Kind.internal_method`, `Kind.concrete_method`, `Kind.constructor`, `Kind.operator` or `Kind.unknown`.
   For category `Category.type_`, kind may be one of: `Kind.plain`, `Kind.struct`, `Kind.enum`, `Kind.union` or `Kind.unknown`.
   For category `Category.normative`, kind may be one of: `Kind.constant`, `Kind.property_`, `Kind.prototype`, `Kind.requirements` or `Kind.unknown`.
   For category `Category.informal`, kind may be only `Kind.unknown` (or the key may be skipped altogether).
  Kind is an identifier, not a string.
  
  Add a name of the entity if it can be guessed from the specification. If not, skip the "name" field. Name is a string.
   If the name contains a double colon ("::") replace it with a dot, i.e. "Number::multiply" becomes "Number.multiply".
   If the name is contained in percent signs ("%") remove them and prepend "well_known." to the name, so "%TypedArray%" becomes "well_known.TypedArray".
   If the name is contained in double square braces, i.e. "[[NAME]]" remove the square braces and leave the inner part only.
  
  Rules for `Category.function`:
   `{"category":Category.function, "kind":Kind.FUNCTION_KIND, "name":"FUNCTION_NAME", "implementation_defined":True/False}`
   If the spec says "syntax - directed operation" then kind is `Kind.syntax_directed_operation`.
   If the spec says "abstract operation" then kind is `Kind.abstract_operation`, however if the function name contains a double colon ("::") or a dot (".") then it is `Kind.abstract_method`.
   If the name is contained in double braces ("[[FUNCTION_NAME]]") then the kind is `Kind.internal_method`.
   If the spec says that the operation is "implementation - defined", "implementation - approximated" or "host - defined", then set the field "implementation_defined" to `True`. Otherwise set it to `False`.
   If the spec says "concrete method", then kind is `Kind.concrete_method`.
   If the spec says that this is a constructor, then kind is `Kind.constructor`.
   If the spec says that this is an operator, then kind is `Kind.operator`.
   If the spec says that this is just a function (without mentioning "abstract"), then kind is `Kind.concrete_operation`, however if the function name contains a double colon ("::") or a dot (".") then it is `Kind.concrete_method`.
   If the spec says that this is an operator, then kind is `Kind.operator`.
    The operator's name should be converted to ASCII and should include valence, i.e. "unary +" should become `"unary_plus".
    If the spec mentions operator's prefix or postfix variant, it should be included too, i.e. "unary_prefix_plusplus".
    If the valence is not specified explicitly, it should be assumed that the operator is binary.
   As a special case, if the spec says "Early Errors" or "Static semantics: Early Errors", the function name is `"early_errors"` and kind is `Kind.syntax_directed_operation`.
   As a special case, if the spec says "Evaluation" or "Runtime semantics: Evaluation", the function name is `"Evaluation"` and kind is `Kind.syntax_directed_operation`.
   As a special case, if the spec sats "Static Semantics: MV", the function name is `"MV"` and kind is `Kind.syntax_directed_operation`.
   If the function kind can not be determined, use `Kind.unknown`.
  Examples:
   "Number::exponentiate ( base, exponent ): The abstract operation Number : : exponentiate" should give `{"category":Category.function, "kind":Kind.abstract_method, "name":"Number.exponentiate", "implementation_defined":False}`
   "StringIndexOf ( string, searchValue, fromIndex ) : The abstract operation StringIndexOf takes arguments ..." should give `{"category":Category.function, "kind":Kind.abstract_operation, "name":"StringIndexOf", "implementation_defined":False}`
   "Static Semantics: MV: A numeric literal stands for a value of the Number type or the BigInt type ." should give `{"category":Category.function, "kind":Kind.syntax_directed_operation, "name":"MV", "implementation_defined":False}`
   "EvalError: The EvalError constructor is % EvalError % ." should give `{"category":Category.function, "kind":Kind.constructor, "name":"well_known.EvalError", "implementation_defined":False}`
   "Error ( message [ , options ] ): This function performs the following steps when called :" should give `{"category":Category.function, "kind":Kind.concrete_operation, "name":"Error", "implementation_defined":False}`
   "Number ( value ): This function performs the following steps when called :" should give `{"category":Category.function, "kind":Kind.concrete_operation, "name":"Error", "implementation_defined":False}`
   "Math.max ( ...args ): Given zero or more arguments , this function calls ..." should give `{"category":Category.function, "kind":Kind.concrete_method, "name":"Math.max", "implementation_defined":False}`
  
  Rules for `Category.type_`:
   `{"category":Category.type_, "kind":Kind.TYPE_KIND, "name":"TYPE_NAME", "superclass":"SUPERCLASS"/None, "subtypes":["TYPE1","TYPE2",...], "values":["VALUE1","VALUE2",...], "specification_type":True/False}`
   TYPE_NAME should be made from the type description and converted to camel case. I.e. "Completion record" should give name `"CompletionRecord"`.
    If TYPE_NAME is "LanguageType", change it to "LanguageValue".
    The words "exotic" and "object" are not part of type name, so "bound function exotic object" should give type name "BoundFunction".
   If the type is an ordinary value type use kind `Kind.plain`.
   If the spec mentions "object" or "record", the kind is `Kind.struct`.
   Try to determine superclass if it is mentioned. Add the superclass type name (a string) or leave `None` if it can not be determined.
    For object types, the superclass is another object type or "Object" (except the type "Object" itself that doesn't have a superclass).
    If the spec says that a type is "exotic object" then its superclass is "ExoticObject".
    For record types, the superclass is another record type or "Record" (except the type "Record" itself that doesn't have a superclass).
    For error types, the superclass is "Error" (except the type "Error" itself whose superclass is "Object").
    Hint: the type "ArrayBuffer" has superclass "Object".
    Hint: the type "Numeric" has superclass "LanguageValue".
    Hint: the type "ExoticObject" has superclass "Object".
   If the spec lists other type names, use kind `Kind.union`. Add the listed type names under the key "subtypes". Otherwise leave "subtypes" as `None`.
   If the spec lists value names, use kind `Kind.enum`. Add the listed value under the key "values". Otherwise leave "values" as `None`.
   If the spec mentions that this is a specification type, set the field "specification_type" to `True`. If the phrase "specification type" is missing from the spec line, the key "specification_type" must be set to `False`: `{"specification_type":False}`
   If the type kind can not be determined, use `Kind.unknown`.
   If a type definition mentions any abstract operations, ignore them.
  Examples:
   "An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language . The ECMAScript language types are Undefined , ..." should give `{"category":Category.type_, "kind":Kind.union, "name":"LanguageValue", "superclass":None, "subtypes":["Undefined", ...], "values":None, "specification_type":False}`
   "The Undefined Type: The Undefined type has exactly one value , called Constant(value='undefined') . Any variable that has not been assigned a value has the value Constant(value='undefined') ." should give `{"category":Category.type_, "kind":Kind.enum, "name":"Undefined", "superclass":None, "subtypes":None, "values":["undefined"], "specification_type":False}`
   "The String type is the set of all ordered sequences of zero or more 16 - bit unsigned integer values ..." should give `{"category":Category.type_, "kind":Kind.plain, "name":"String", "superclass":None, "subtypes":None, "values":None, "specification_type":False}`
   "ECMAScript has two built - in numeric types : Number and BigInt . The following abstract operations are defined over these numeric types ." should give `{"category":Category.type_, "kind":Kind.union, "name":"Numeric", "superclass":None, "subtypes":["Number", "BigInt"], "values":None, "specification_type":False}`
   "The Number type has exactly 18,437,736,874,454,810,627 values ..." should give `{"category":Category.type_, "kind":Kind.plain, "name":"Number", "superclass":None, "subtypes":None, "values":None, "specification_type":False}`
   "... Environment Record is an abstract class with three concrete subclasses : Declarative Environment Record , ... " should give `{"category":Category.type_, "kind":Kind.union, "name":"EnvironmentRecord", "superclass":"Record", "subtypes":["DeclarativeEnvironmentRecord", ...], "values":None, "specification_type":False}`
   "Function Environment Records and Module Environment Records are subclasses of Declarative Environment Record ." should give `{"category":Category.type_, "kind":Kind.union, "name":"DeclarativeEnvironmentRecord", "superclass":"EnvironmentRecord", "subtypes":["FunctionEnvironmentRecord", "ModuleEnvironmentRecord"], "values":None, "specification_type":False}`
   "A module namespace exotic object is an exotic object ..." should give `{"category":Category.type_, "kind":Kind.struct, "name":"ModuleNamespace", "superclass":"ExoticObject", "subtypes":None, "values":None, "specification_type":False}`
   "Every Function instance is an ECMAScript function object ..." should give `{'category': Category.type_, 'kind': Kind.struct, 'name': 'Function', 'superclass': 'Object', 'subtypes': None, 'values': None, 'specification_type': False}`
   "An immutable prototype exotic object is an exotic object ..." should give `{"category":Category.type_, "kind":Kind.struct, "name":"ImmutablePrototype", "superclass":"ExoticObject", "subtypes":None, "values":None, "specification_type":False}`
   "The Enum Specification Type: Enums are values which are internal to the specification ..." should give `{"category":Category.type_, "kind":Kind.plain, "name":"Enum", "superclass":None, "subtypes":None, "values":None, "specification_type":True}`
   "Set objects are collections of ECMAScript language values." should give `{"category":Category.type_, "kind":Kind.struct, "name":"SetObject", "superclass":"Object", "subtypes":None, "values":None, "specification_type":False}`
   "The List and Record Specification Types: The List type is used to explain the evaluation of argument lists ..." should give `{"category":Category.type_, "kind":Kind.plain, "name":"List", "superclass":None, "subtypes":None, "values":None, "specification_type":True}\n{"category":Category.type_, "kind":Kind.struct, "name":"Record", "superclass":None, "subtypes":None, "values":None, "specification_type":True}`
   "The Set and Relation Specification Types: The Set type is used to explain a collection of unordered elements for use in the memory model." should give `{"category":Category.type_, "kind":Kind.plain, "name":"Set", "superclass":None, "subtypes":None, "values":None, "specification_type":True}\n{"category":Category.type_, "kind":Kind.plain, "name":"Relation", "superclass":None, "subtypes":None, "values":None, "specification_type":True}`
   "An Array Iterator is an object that represents a specific iteration over some specific Array instance object." should give `{"category":Category.type_, "kind":Kind.struct, "name":"ArrayIterator", "superclass":"Object", "subtypes":None, "values":None, "specification_type":False}`
   "Script Records: A Script Record encapsulates information about a script being evaluated." should give `{"category":Category.type_, "kind":Kind.struct, "name":"ScriptRecord", "superclass":"Record", "subtypes":None, "values":None, "specification_type":False}`
  
  Rules for `Category.normative`:
   `{"category":Category.normative, "kind":Kind.KIND, "name":"NAME"}`
   If the spec says this is a property (outside name) or internal slot, then kind is `Kind.property_`.
   If the spec says this is a prototype object (outside name), then kind is `Kind.prototype`.
   If the spec says this is a constant or literal, then kind is `Kind.constant`.
   If the kind can not be determined, use `Kind.unknown`.
  Examples:
   "a single special 'NaN' value" should give `{"category":Category.normative, "kind":Kind.constant, "name":"NaN"}`
   "The % ForInIteratorPrototype % object :" should give `{"category":Category.normative, "kind":Kind.constant, "name":"well_known.ForInIteratorPrototype"}`
   "All ordinary objects have an internal slot called `Prototype`" should give `{"category":Category.normative, "kind":Kind.property_, "name":"Prototype"}`
   "Constructor Properties of the Global Object / Int32Array ( . . . ): See 23 . 2 . 5 ." should give `{"category":Category.normative, "kind":Kind.property_, "name":"Int32Array"}`
   "get %TypedArray%.prototype.buffer: % TypedArray % Terminal('.prototype.buffer') is an accessor property ..." should give `{"category":Category.normative, "kind":Kind.property_, "name":"well_known.TypedArray.prototype.buffer"}`
   "The Function prototype object :" should give `{"category":Category.normative, "kind":Kind.prototype, "name":"Function"}`
   "Object prototype object :" should give `{"category":Category.normative, "kind":Kind.prototype, "name":"Object"}`
  
  If none of the above holds and the spec line does not correspond to any programming concept, the category is "informal".
   `{"category":Category.informal}`
   Informal clauses do not have a "name". The only allowed kind is `Kind.unknown` or nothing at all.
  Examples:
   "Algorithms within this specification manipulate values each of which has an associated type . The possible value types are exactly those defined in this clause ." should give `{"category":Category.informal}`
   "Well-Known Symbols: Well - known symbols are built - in Symbol values that are explicitly referenced ..." should give `{"category":Category.informal}`
   "Property Attributes: Attributes are used in this specification ..." should give `{"category":Category.informal}`
   "Definitions:: The target of an internal method is the object ..." should give `{"category":Category.informal}`
   "Return value:: The value returned by any internal ..." should give `{"category":Category.informal}`
   "In addition to those defined in this section ..." should give `{"category":Category.informal}`
   "Liveness: For some set of objects and / or symbols ..." should give `{"category":Category.informal}`
   "Execution: At any time , if a set of objects and / or symbols ..." should give `{"category":Category.informal}`
   "Forward Progress: For an agent to make forward progress ..." should give `{"category":Category.informal}`
   "There are four types of ECMAScript code :" should give `{"category":Category.informal}`
   "Comments can be either single or multi - line " should give `{"category":Category.informal}`
   "Unicode escape sequences are permitted " should give `{"category":Category.informal}`
   "Nonterminal('IdentifierName') and Nonterminal('ReservedWord') are tokens that are interpreted according" should give `{"category":Category.informal}`
   "Most ECMAScript functions make an arguments object available to their code" should give `{"category":Category.informal}`
   "A regular expression literal is an input element that is converted to a RegExp object" should give `{"category":Category.informal}`
   "A keyword is a token that matches ..." should give `{"category":Category.informal}`
   "A string literal is 0 or more Unicode code points enclosed in single or double quotes ..." should give `{"category":Category.informal}`
   "Supplemental Syntax: When processing an instance of the production" should give `{"category":Category.informal}`
   "An Nonterminal('ArrayLiteral') is an expression describing the initialization of an Array" should give `{"category":Category.informal}`
   "An object initializer is an expression describing the initialization" should give `{"category":Category.informal}`
   "The ECMAScript language implicitly performs automatic type conversion as needed" should give `{"category":Category.informal}`
   "This specification defines several kinds of built - in exotic objects" should give `{"category":Category.informal}`
   "Object Internal Methods and Internal Slots: The actual semantics of objects ..." should give `{"category":Category.informal}`
   "Properties are accessed by name , using either the dot notation ..." should give `{"category":Category.informal}`
   "The Object Type / Object Internal Methods and Internal Slots : The actual semantics of objects , in ECMAScript , are specified via algorithms called internal methods " should give `{"category":Category.informal}`
   "A new instance of one of the `NativeError` objects below or of the AggregateError object is thrown ..." should give `{"category":Category.informal}`
   "Normative Optional , Legacy" should give `{"category":Category.informal}`
   "The result of evaluating a relational operator ..." should give `{"category":Category.informal}`
   "A tagged template is a function call where the arguments of the call are derived ..." should give `{"category":Category.informal}`
   "The evaluation of an argument list produces a List of values ." should give `{"category":Category.informal}`
   "A keyword is a token that matches Nonterminal('IdentifierName') , but also has a syntactic use ;" should give `{"category":Category.informal}`
   "The result of evaluating a relational operator is always of type Boolean , reflecting whether the relationship named by the operator holds between its two operands ." should give `{"category":Category.informal}`
   "Each of these objects has the structure described below" should give `{"category":Category.informal}`
 </prompt>

 <prompt context="Prototype">
  <!-- Prompt to generate a prototype of a function i.e. name with arguments and types. -->
  Provide a prototype for the provided function description.

  A prototype is a dict where keys are strings.
   The first element is the function kind `"__kind":FUNCTION_KIND`, one of: `Kind.abstract_operation`, `Kind.syntax_directed_operation`, `"Kind.concrete_method`, `Kind.internal_method`, `Kind.constructor`.
   If the function is of kind `Kind.concrete_method` or Kind.internal_method", there is an additional element `"__class":CLASS_NAME` where the CLASS_NAME is the name of the class this method is from, as specified.

   The next element is the function name (a string) `"__name":FUNCTION_NAME`, as provided in the spec.
    If the provided name contains a slash, like "AAAA / BBBB", connect it with underscore: `AAAA_BBBB`.

   If the function is of kind `Kind.syntax_directed_operation`, there is special first argument `"self":Self`.
   If the function is of kind `Kind.concrete_method`, there is special first argument `"VARIABLE":Self` where the argument name VARIABLE is provided in the spec.
   Next elements are arguments with types, in the format `ARGUMENT: TYPE`. ARGUMENT is a string and TYPE is a valid Python type identifier. Note that TYPE is not a string and shouldn't be in quotes.
    If ARGUMENT is a Python reserved word, a Python built-in function name or one of standard Python type names, append underscore.
    Convert argument name `"len":TYPE` to `"len_":TYPE`.
    Convert argument name `"str":TYPE` to `"str_":TYPE`.
    Convert argument name `"min":TYPE` to `"min_":TYPE`.
    Convert argument name `"type":TYPE` to `"type_":TYPE`.
    Convert argument name `"set":TYPE` to `"set_":TYPE`.
    Convert argument name `"match":TYPE` to `"match_":TYPE`.
    Convert argument name `"map":TYPE` to `"map_":TYPE`.
   The return type, if present, is provided in the last element as: `"__return": RETURN_TYPE`.
  I.e.: `{"__kind":Kind.FUNCTION_KIND, "__name":"FUNCTION_NAME", "ARG1":TYPE1, "ARG2":TYPE2, ..., "__return":RETURN_TYPE}`.
  Make sure TYPE1, TYPE2, ... and RETURN_TYPE are not strings but identifiers.

  When you see a phrase "`min` ( a Number )" it should result in argument spec: `"min_":Number`.
  When you see a phrase "`type` ( a TypedArray element type )" it should result in argument spec: `"type_":TypedArrayElementType`.
  When you see a phrase "`map` ( an ECMAScript language value )" it should result in argument spec: `"map_":LanguageValue`.

  An "abstract operation" is just a regular function. Use FUNCTION_KIND = `Kind.abstract_operation`.
   If the function name of the abstract operation contains double colon ("::") replace it with a dot ("."), so "NAME1 : : NAME2" becomes `NAME1.NAME2`.

  If the spec says "syntax - directed operation", then it is a method, so insert additional `"self": Self` as the first argument (even if the spec says there are no arguments). Use FUNCTION_KIND = `Kind.syntax_directed_operation`.
   I.e.: `{"__kind":Kind.syntax_directed_operation, "__name":"FUNCTION_NAME", "self":Self, "arg1":Type1, "arg2":Type2, "__return":ReturnType}`.

  A "concrete method" of some class is a function that will be a method of that class, so add the specified symbol (with type) as the first argument. Use FUNCTION_KIND = `Kind.concrete_method`.
   Use the provided special variable name instead of `self` in concrete methods. I.e. if the spec says "The METHOD_NAME concrete method of a CLASS_NAME `VARIABLE` ..." use VARIABLE as the first argument.
   I.e.: `{"__kind":Kind.concrete_method, "__class":CLASS_NAME, "__name":"FUNCTION_NAME", "VARIABLE":Self, "arg1":Type1, "arg2":Type2, "__return":ReturnType}`.

  If some type can not be determined, omit it, providing just the argument name.
  If the spec explicitly says the argument is optional (like "optional argument"), make the whole type an union with `None`. So if the spes says the optional argument has some type, like `"ARG":TYPE`, make it `"ARG":(TYPE) | None`.
  When one argument is optional, all subsequent arguments are optional too, so add the `None` alternative to all arguments following the one marked as optional, except "__return" type. (Preceding arguments are unaffected.)
  Example: "optional argument `env` ( an Environment Record or `undefined` )" becomes `"env":(EnvironmentRecord | Undefined) | None`.
  Note: `null` or `undefined` argument types are not enough to consider the argument optional. The spec must explicitly say "optional argument", otherwise the argument is mandatory.

  If the spec says about many possible types (like "TYPE1 or TYPE2"), connect them into union using the `|` operator, like: `TYPE1 | TYPE2`.
  If the spec says "List of TYPEs" where the second type is plural, it means `List[TYPE]`.
  If the spec says "a set of TYPEs" where the second type is plural, it means `Set[TYPE]`.

  When the spec says "Nonterminal('XXX') Parse Node" convert it to `ParseNode[Nonterminal[{'XXX'}]]`.
  When the spec simply says "Nonterminal('XXX')" convert it to `Nonterminal[{'XXX'}]`.
  When the spec mentions alternative of nonterminals, like "Nonterminal('AAA') or Nonterminal('BBB')" convert it to `Nonterminal[{'AAA', 'BBB'}]`.

  When the spec says "Terminal('XXX')" convert it to `Terminal[{'XXX'}]`.
  When the spec mentions alternative of terminals, like "Terminal('AAA') or Terminal('BBB')" convert it to `Terminal[{'AAA', 'BBB'}]`.

  When the spec says "&lt;constant&gt; 'XXX'" convert it to `Constant[{Constant.XXX}]`.
   Replace hyphen "-" with underscore "_" in XXX.
   If XXX is "async", use `Constant.async_`.
   If XXX is "all", use `Constant.all_`.
   If XXX is "global", use `Constant.global_`.
  When the spec mentions alternative of constants, like "&lt;constant&gt; 'AAA' or &lt;constant&gt; 'BBB'" convert it to `Constant[{Constant.AAA, Constant.BBB}]`.
   Replace hyphen "-" with underscore "_" in AAA and BBB.
   If AAA or BBB is "async", use `Constant.async_`.
   If AAA or BBB is "all", use `Constant.all_`.
   If AAA or BBB is "global", use `Constant.global_`.
   Example: "&lt;constant&gt; 'sync' or &lt;constant&gt; 'async'" should yield `Constant[{Constant.sync, Constant.async_}]`.

  When the spec mentions an error type, like SyntaxError, TypeError or WHATEVERerror, use the type `Error['WHATEVERError']`. Here 'WHATEVERError' is a string, so put it in quotes.
  Convert the error name to camel case, i.e. "Typeerror" becomes "TypeError".
  If the spec simply says "error" without a specific subtype, use `Error`.

  A "completion" is a type `CompletionRecord`. Additional qualifiers possible on a completion are:
   "normal completion" is `CompletionRecord[Constant[{Constant.normal}]]`
   "abrupt completion" is `CompletionRecord[Constant[AbruptCompletions]]]`
   "XXX completion" (except when XXX is "abrupt") is `CompletionRecord[Constant[{Constant.XXX}]]` (Replace hyphen "-" with "_" in XXX. If XXX is "return", use `Constant.return_`. If XXX is "break", use `Constant.break_`. If XXX is "continue", use `Constant.continue_`.)
   "normal completion containing YYY" is CompletionRecord[Constant[{Constant.normal}], YYY]`
  An alternative of `CompletionRecord` types should not be merged and should stay as a union.
   I.e. "return either a normal completion containing &lt;constant&gt; 'unused' or a throw completion" should give: `CompletionRecord[Constant[{Constant.normal}], Constant[{Constant.unused}]] | CompletionRecord[Constant[{Constant.throw}]]`.

  A "record" type is a class `Record` with additional field specification. Add those fields as a dict in square braces. I.e. when the spec says "Record with fields `AAA` (a TYPE1) and `BBB` (a TYPE2)", use: `Record[{'AAA':TYPE1, 'BBB':Type2}]`

  When the spec says about subclass of a type, just use the base type.

  When the spec uses the phrase "a set of algorithm steps , or some other definition of a function's behaviour provided in this specification" just use the type `FunctionSpec`.

  When the spec says "mathematical value", use `MathematicalValue`.
  When the spec says "ECMAScript language value", use `LanguageValue`.
  When the spec says "function object" or "built - in function object" or "ECMAScript function object", use `Function`.
  When the spec says "ECMAScript code execution context" or "execution context", use `ExecutionContext`.
  When the spec uses type name "boolean" or "bool", use `Boolean`.
  When the spec uses type name "integer" or "int" or "integral number", use `Number['int']`.
  When the spec uses type name "non - negative integer", use `Number['uint']`.
  When the spec uses type name "Number", use `Number`.
  When the spec uses type name "string" or "str", use `String`.
  When the spec uses type name "list" or "sequence", use `List`.
  When the spec uses type name "object", use `Object`.
  When the spec uses type name "ordinary object", use `OrdinaryObject`.
  When the spec uses type name "set", use `Set`.
  When the spec uses type name "array", use `Array`.
  When the spec uses type name "TypedArray", use `TypedArray`.
  When the spec uses type name "BigInt", use `BigInt`.
  When the spec says the function returns "null", use type `Null`.
  When the spec says the function returns "undefined", use type `Undefined`.
  When the spec says the function returns "∞", use type `Number['inf']`.
  When the spec says the function returns "NaN", use type `Number['nan']`.
  When the spec says "code point", use type `CodePoint`.
  When the spec says "time value", use type `TimeValue`.
  When the spec says "RegExp Record", use type `RegExp`.
  When the spec says "any value", use type `AnyValue`.
  When the spec says "SOME_TYPE except OTHER_TYPE", use `SOME_TYPE - OTHER_TYPE`.
  When the spec says "property key" or "property keys" it means the type `PropertyKey`.
  When the spec says "0 or 1" use `Bit`.
  When the spec says "byte" use `Byte`.

  If none of the rules above apply and a type spec ends with "Record", include that "Record" as part of the type name. I.e. "Some Thing Record" should be `SomeThingRecord`.
  If none of the rules above apply and a multi-word type description ends with "Object", remove the final word "Object" from the type name. I.e. "Some Thing Object" should be just `SomeThing` (skipping "Object").

  If the spec says "The abstract operation Set ...", replace the function name with "Set_", so use: `{"__kind":Kind.abstract_operation, "__name":"Set_", ...}`. This is to distinguish the function from type name. Function name should be "Set_" and type name should be "Set".
  If the spec says "The abstract operation Map ...", replace the function name with "Map_", so use: `{"__kind":Kind.abstract_operation, "__name":"Map_", ...}`. This is to distinguish the function from type name. Function name should be "Map_" and type name should be "Map".
  If the spec says "The abstract operation eval ...", replace the function name with "eval_", so use: `{"__kind":Kind.abstract_operation, "__name":"eval_", ...}`.

  Example:
   If you receive the input: "The syntax - directed operation Evaluation takes no arguments and returns a Completion Record ."
   respond with: `{"__kind":Kind.syntax_directed_operation", "__name":"Evaluation", "self":Self, "__return": CompletionRecord}`

  <line context="Syntax error 1">Return a well-formed Python dict. Append underscore to argument names that are reserved words (async, match, break, continue) or standard function names (map, min, max, str, list).</line>
  <line context="Syntax error 2">Double check for syntax errors. Output text that is correctly formatted Python code. Make sure the returned dict has keys "__kind" and "__name". If one of the dict keys is "min", change it to "min_".</line>
  <line context="Syntax error 3">FOR GOD'S SAKE, DO NOT MAKE SYNTAX ERRORS FOR ONCE, PLEASE!</line>
 </prompt>

 <prompt context="Algorithm">
  <!-- Prompt present in all requests to make a function from ECMA specification. -->
  Whevever the specification uses function call notation with braces like "&lt;function&gt; `FUNCTION` ( ARGS )", take it as `FUNCTION(ARGS)`.

  Whenever the specification says "with argument" or "with arguments", put those arguments in the relevant method call.
  Literals in triangular braces like "« A, B, C »" are lists. Convert them to `[A, B, C]`. Also, "« »" is an empty list `[]`.
  Whenever the specification says "numeric value of SOMETHING", use the method `SOMETHING.NumericValue()`.
  Keep the name of the method `Contains` as it is; do not convert to lowercase.
  But when the spec says "EXPR1 contains EXPR2" where the word "contains" is lowercase and not in apostrophes and not preceded by "&lt;method&gt;" qualifier, then render it as `EXPR1 in EXPR1`.

  When the spec uses "&lt;constant&gt; 'SOMETHING'" convert it to `Constant.SOMETHING` (but consider the special cases below). Replace hyphen "-" with underscore "_" in SOMETHING. Also append underscore if SOMETHING is a reserved word.
   When you see "&lt;constant&gt; 'async'", use `Constant.async_`.
   When you see "&lt;constant&gt; 'global'", use `Constant.global_`.
   When you see "&lt;constant&gt; 'all'", use `Constant.all_`.
   When you see "&lt;constant&gt; 'return'", use `Constant.return_`.
   When you see "&lt;constant&gt; 'break'", use `Constant.break_`.
   When you see "&lt;constant&gt; 'continue'", use `Constant.continue_`.
   But dont append underscore when you see "&lt;constant&gt; 'empty'", use `Constant.empty`.

  Use the following constant mapping:
   "undefined" to `undefined`;
   "null" to `null`;
   "true" to `True`;
   "false" to `False`;
   "+ ∞" to `+Infinity`;
   "- ∞" and  "_ ∞" to `-Infinity`.
  Use the constant `null` when documentation says "null".
  The special expression "+ 0 ( 𝔽 )" means `+Zero` and the special expression "- 0 ( 𝔽 )" and "_ 0" means `-Zero`, but if "0" appears in other context just use literal `0`.
  The constant "NaN" is just `NaN`.

  When testing if "`VARIABLE` is undefined", use equality operator: `VARIABLE == undefined`.
  When testing if "`VARIABLE` is null", use equality operator: `VARIABLE == null`.
  When testing if "`VARIABLE` is + 0 ( 𝔽 )", use equality operator: `VARIABLE == +Zero`.
  When testing if "`VARIABLE` is - 0 ( 𝔽 )", use equality operator: `VARIABLE == -Zero`.
  When testing if "`VARIABLE` is + ∞", use equality operator: `VARIABLE == +Infinity`.
  When testing if "`VARIABLE` is - ∞", use equality operator: `VARIABLE == -Infinity`.
  When using a value in a test "if VALUE is true ...", test for boolean value: `if VALUE: ...`.
  When using a value in a test "if VALUE is false ...", negate the value: `if not VALUE: ...`.

  Whenever the specification says "VALUE is a TYPE" or "VALUE is an TYPE" it is a type check, so use `isinstance(VALUE, TYPE)`, except when TYPE is a Nonterminal.
  When testing for types, like `Bool`, `String`, `Number`, `BigInt`, `List`, `Set`, `Array`, `Object`, 'Function`  etc. using the construction "VALUE is a TYPE", keep the original type name and do not change it to Python equivalent, i.e. `isinstance(VALUE, TYPE)`.
  When the spec says "list of TYPE", use `List[TYPE]`.
  Whenever the specification line starts with "Assert :" insert `assert CONDITION` where CONDITION is Python code. Interpret the rest of the line after "Assert :" as the condition to check.
  To check if a VALUE is a "TYPE completion", test if its `Type` attribute is equal to `Constant.TYPE'`.
  To check if a VALUE is an "abrupt completion", test if its `Type` attribute is not equal to `Constant.normal`.
  Whenever the specification line starts with "Note : TEXT" insert a comment into generated code (like `# TEXT`) containing the rest of the spec line.

  Whenever some "let" or "set" statement contains the token "&lt;return_if_abrupt&gt;", save the result to some temporary variable TEMPVAR (use some unique name like `result_NUM = ...`) and check if the call result is an abrupt completion.
   If yes, return the result TEMPVAR from the function.
   If no, take the attribute `Value` of TEMPVAR and assign it to VARIABLE.
   Example:
    "let `VARIABLE` be &lt;return_if_abrupt&gt; &lt;function&gt; ..." or
    "let `VARIABLE` be &lt;return_if_abrupt&gt; &lt;method&gt; ..." should give:
```
	TEMPVAR = ...
	if TEMPVAR.Type != Constant.normal:
		return TEMPVAR
	else:
		VARIABLE = TEMPVAR.Value
```
   Likewise, "Let `ref` be &lt;return_if_abrupt&gt; &lt;method&gt; `Evaluation` of `constructExpr`" should give:
```
	TEMPVAR = constructExpr.Evaluation()
	if TEMPVAR.Type != Constant.normal:
		return TEMPVAR
	else:
		ref = TEMPVAR.Value
```

  Whenever a "perform" statement contains the token "&lt;return_if_abrupt&gt;", save the result to some TEMPVAR with unique temporary name (i.e. `result_NUM = ...`) and check if it is an abrupt completion. If yes, return the value from the function.
  Example:
   "perform &lt;return_if_abrupt&gt; &lt;function&gt; ..." or
   "perform &lt;return_if_abrupt&gt; &lt;method&gt; ..."  should give:
```
	TEMPVAR = ... # perform
	if TEMPVAR.Type != Constant.normal:
		return TEMPVAR
```

  Whenever a "return" statement contains the token "&lt;return_if_abrupt&gt;" no special action is needed; just return the result unmodified. Do not extract fields nor create `CompletionRecord`; it will be done automatically.
  Do not create `CompletionRecord` unless explicitly told so.
   "return &lt;return_if_abrupt&gt; &lt;function&gt; CALL ( ... )" should give:
```
	return CALL(...) # abrupt completions are handled automatically
```
  Likewise, "Return &lt;return_if_abrupt&gt; `base` . InitializeBinding ( `V` . `ReferencedName` , `W` )" should give:
```
	return base.InitializeBinding(V.ReferencedName , W) # abrupt completions are handled automatically
```
  Likewise, "Return &lt;return_if_abrupt&gt; &lt;method&gt; `EvaluateBody` of `F` . `ECMAScriptCode` with arguments `F` and `argumentsList` ." should give:
```
	return F.ECMAScriptCode.EvaluateBody(F, argumentList)
```
  Likewise, "Return &lt;return_if_abrupt&gt; &lt;function&gt; `EvaluateStringOrNumericBinaryExpression` ( Nonterminal('BitwiseORExpression') , Terminal('|') , Nonterminal('BitwiseXORExpression') ) ." should give:
```
	return EvaluateStringOrNumericBinaryExpression(Nonterminal('BitwiseORExpression'), Terminal('|'), Nonterminal('BitwiseXORExpression'))
```

  Whenever some "let" or "set" statement contains the token "&lt;raise_if_abrupt&gt;", save the result to some temporary variable TEMPVAR (use some unique name, i.e. `result_NUM = ...`) and check if it is an abrupt completion.
   If yes, raise RuntimeError with error message referencing the function or method name that returned the abrupt completion.
   If no, substitute the VARIABLE with the attribute `Value` of TEMPVAR.
  Example:
   "let `VARIABLE` be &lt;raise_if_abrupt&gt; &lt;function&gt; `ArrayCreate` ( ... )" should give:
```
	TEMPVAR = ArrayCreate (...)
	if TEMPVAR.Type != Constant.normal:
		raise RuntimeError("As per spec the function ArrayCreate must return normal completion.")
	else:
		VARIABLE = TEMPVAR.Value
```

  Whenever a "perform" statement contains the token "&lt;raise_if_abrupt&gt;", save the result to some TEMPVAR with unique temporary name (i.e. `result_NUM = ...`) and check if it is an abrupt completion.
   If yes, raise RuntimeError with error message referencing the function or method name that returned the abrupt completion.
  Example:
   "perform &lt;raise_if_abrupt&gt; &lt;function&gt; `InitializeReferencedBinding` ( ... )" should give:
```
	TEMPVAR = InitializeReferencedBinding(...) # perform
	if TEMPVAR.Type != Constant.normal:
		raise RuntimeError("As per spec the function InitializeReferencedBinding must return normal completion.")
```

  Whenever the specification says "&lt;function&gt; `𝔽` ( VALUE )" it means `Number(VALUE)`.
  Whenever the specification says "`VALUE` (𝔽)" it means `Number(VALUE)`.
  Whenever the specification says "Number value for VALUE" it means `Number(VALUE)`.

  Whenever the specification says "&lt;function&gt; `ℤ` ( VALUE )" it means `BigInt(VALUE)`.
  Whenever the specification says "`VALUE` (ℤ)" it means `BigInt(VALUE)`.
  Whenever the specification says "BigInt value for VALUE" it means `BigInt(VALUE)`.

  Whenever the specification says "&lt;method&gt; `ℝ` ( VALUE )" it means `VALUE.MV()`.
  Whenever the specification says "mathematical value of VALUE" it means `VALUE.MV()`.
  Do not use the expression `ℝ(XXX)`. Convert it to `XXX.MV()` instead.

  Expressions of the form "U + XXXX ( DESCR )" are Unicode codepoints. Convert them to `chr(0xXXXX)` and put DESCR in the comment in the same line. To obtain numeric value of such Unicode codepoint use function `ord`.

  To create a new "ECMAScript code execution context" or simply "execution context", call the constructor `ExecutionContext`.
  To obtain the running execution context, call `execution_context_stack[-1]`.
  Before a new execution context is pushed onto context stack, the old context must be stopped, unless the spec explicitly says to stop it at some different point.
  After a new execution context is pushed onto context stack, it must be started by calling its `start` method.
  Before an execution context is removed (popped) from the stack, it must be stopped by calling its `stop` method.
  After an execution context has been popped from the stack, the context that is now on the top must be started. Do not perform this step if the stack is empty, the spec says not to start the old context or if the spec says to start it at some different point.
  This implementation does not need any implementation - defined initialization of execution context, so no special action is needed.
  To discard all resources associated with the current execution context first stop it by calling `execution_context_stack[-1].stop()`, then pop it from the context stack.
  To suspend an execution context (when it is on the stack), call its `stop` method. Do not pop it from the stack.
  To resume an execution context (when it is on the stack), call its `start` method. It must be at the top of the stack, so use `execution_context_stack[-1].start()`.
  
  To check for duplicates, use `len(COLLECTION) == len(set(COLLECTION))`.

  If other rules don't apply, when the specification says "A is B", use `A == B`; when the specification says "A is not B", use `A != B`.

  Never return CompletionRecord unless the spec explicitly says "Return Completion Record". ReferenceRecord is not CompletionRecord.
  Do not return `CompletionRecord(Type=Constant.normal, Value=XXX)`, just return `XXX` instead.

  Remove double square braces, i.e. "[ [ SOMETHING ] ]" becomes `SOMETHING`.
  Replace dot - double square brace expression with attribute lookup, i.e. convert "OBJ . [ [ SOMETHING ] ]" to `OBJ.SOMETHING`.
  Whenever an expression (except those starting with "Symbol.") is between percent signs (like "% ID %" or "% ID1.ID2 %") take it as an attribute of `current_realm().Intrinsics`, i.e. `current_realm().Intrinsics.ID` or `current_realm().Intrinsics.ID1.ID2`.
  If you see a dot - double square brace - percent expression, like "OBJ . [ [ % ID % ] ]" or "OBJ . [ [ % ID1.ID2 % ] ]", replace that syntax with attribute lookup, like `OBJ.ID` or `OBJ.ID1.ID2`.
  If a percent identifier starts with "Symbol", like "% Symbol.FIELD %", just omit the percent signs, i.e. use `Symbol.FIELD`. Rename "Symbol.match" to `Symbol.match_`.
  If an expression with percents appears in spec inside quotation marks, like \"%SOMETHING%\" then it is a normal string. Do not modify it, just insert in the code unmodified: `"%SOMETHING%"`.

  To obtain the current Realm Record use `current_realm()`.
  To obtain the Agent Record of the surrounding agent use `current_agent()`.

  Keep terminal literals as they are, i.e. "Terminal('XXX')" in the spec should give `Terminal('XXX')` in the code.
  When comparing a string with a `Terminal`, check its `value` field, that is `STRING == TERMINAL.value`. Also, when checking if a `Terminal` is a member of string collection, use `TERMINAL.value in COLLECTION`.
  When comparing two `Terminal`s, use comparison operator: `TERMINAL1 == TERMINAL2`.

  Whenever the specification says "`VARIABLE` is not present", test it as `VARIABLE is None`. Similarly "`VARIABLE` is present" means `VARIABLE is not None`.

  To create a new ECMAScript function object call the constructor `Function`.

  <line context="Syntax error 1">Use correct indentation. Append underscore to identifiers that are reserved words (return, async, match, break, continue).</line>
  <line context="Syntax error 2">Double check for syntax errors. Output text that is correctly formatted Python code.</line>
  <line context="Syntax error 3">FOR GOD'S SAKE, DO NOT MAKE SYNTAX ERRORS FOR ONCE, PLEASE!</line>
 </prompt>

 <prompt context="Abstract Operation">
  <!-- Prompt present in all requests to make an abstract operation. Also present in syntax-directed operations except Evaluation and Early Errors. -->
  To test if a number is a "NaN", use `number == NaN`.
  To test if a number is (plus or minus) "∞", use `number is +Infinity` or `number is -Infinity`.
  To test if a number is a "+ 0 ( 𝔽 )" or "- 0 ( 𝔽 )", use `number is +Zero` or `number is -Zero`.
  To check if an object OBJ has internal method METHOD, use `hasattr(OBJECT, 'METHOD')`.
  To check if an object OBJ has at least one internal method, use, `any(hasattr(OBJECT, _method) for _method in all_internal_methods)`.
  The list of all internal method names is in global variable `all_internal_methods`. The list of essential internal methods is in global variable `essential_internal_methods`.
  To check if an object OBJ has a ATTR field, use `hasattr(OBJ, 'ATTR')`.
  To check if an object OBJ has a property PROP, use `PROP in OBJ`.
  To check in a value is null, use `value == null`. To check if value is not null, use `value != null`.
  
  To test if a value is integer, use `isinstance(value, Number['int'])`.
  To test if a VALUE is a Private Name, use `isinstance(VALUE, PrivateName)`.
  `GlobalSymbolRegistry` is a global variable.

  To test if a value is finite, use `not isinstance(value, Number['inf'])`.
  To test if a value is not finite, use `isinstance(value, Number['inf'])`.
  Examples:
   "`hour` is not finite" should give `isinstance(hour, Number['inf'])`
   "`min` is not finite" should give `isinstance(min_, Number['inf'])`
   "`sec` is not finite" should give `isinstance(sec, Number['inf'])`
   "`ms` is not finite" should give `isinstance(ms, Number['inf'])`.

  To create an accessor property use the constructor with attribute names as arguments. The default attribute values are provided here: `AccessorProperty(Get=undefined, Set=undefined, Enumerable=False, Configurable=False)`.
  To create an data property use the constructor with attribute names as arguments. The default attribute values are provided here: `DataProperty(Value=undefined, Writable=False, Enumerable=False, Configurable=False)`.

  Assume all external symbols referenced by the current function are already defined and do not provide their implementations inside the function.

  Whenever the specification says to "set SOMETHING as described in CHAPTER_NUMBER", use: `SOMETHING = as_described_in('CHAPTER_NUMBER')`. Remove whitespace from CHAPTER_NUMBER.
  When the specification says to create an instance of TYPE followed by dict-like initializer, like "TYPE { KEY1: VALUE1, KEY2: VALUE2, ... }", pass the dict initializer to the type constructor using kwargs syntax, like: `TYPE(**{KEY1:VALUE1, KEY2,VALUE2, ...})`.
  I.e. when the spec says to "return the Record { `Job` : `job` , `Realm` : `handlerRealm` }", use `return Record(**{'Job': job, 'Realm': handlerRealm})` or alternatively `return Record(Job=job, Realm=handlerRealm)`.

  When the specification says about an "error" as a type, use the type name `Error`. Similarily, "List of errors" means `List[Error]`. To check if a VALUE is an error, use `isinstance(VALUE, Error)`.
  When the specification says about an "syntax error" as a type or "SyntaxError", use the type name `Error['SyntaxError']`.

  Do not use `current_agent().AgentRecord`; just use `current_agent()` instead. The function `current_agent()` returns the Agent Record.

  If the function spec consists of only one operation, to return an attribute of an object, "(1.) Return `O` . `Extensible`", then just return this attribute: `return O.Extensible`.

  If the function spec consists of only one operation, to return a result of function "ValidateAndApplyPropertyDescriptor" on some arguments, just call it and return the result:
   "(1.) Return &lt;function&gt; `ValidateAndApplyPropertyDescriptor` ( `undefined` , "" , `Extensible` , `Desc` , `Current` ) ."
   `return ValidateAndApplyPropertyDescriptor(undefined, "", Extensible, Desc, Current)`

  The spec may define an inner function (also called a "closure") using syntax: "Let `CLOSURE_NAME` be a new CLOSURE_TYPE with ARGUMENTS that captures NONLOCALS and performs the following steps when called :".
  When creating an inner function with a specified type (like "MatcherContinuation", "JobAbstractClosure", "AbstractClosure") add that type as a decorator over that closure. If no type is specified, add a decorator `@AbstractClosure`.
  When returning an inner function without a specified name i.e. "Return a new Matcher", give it a name by prepending underscore to the type name and apply a decorator as above (i.e. `@Matcher\ndef _Matcher`). Then return the created closure (`return _Matcher`).
  But if the spec provides a name, like "Let `closure` be an Abstract Closure ..." then use that name.
  When the spec says that an inner function "captures" some variables of the host function, add them as `nonlocal` to the inner function. Make sure that those identifiers appear as variables in the host function.
   Example:
    When a spec line says: "Let `setterClosure` be a new Abstract Closure with parameters ( `value` ) that captures `name` and `env` ..."
    1. Make sure `name` and `env` are variables of the outer function, not arguments of the current function. If they are arguments of the toplevel function, do not put them in `nonlocal` clause. Nonlocals must be inside closure.
    2. Yield the code:
```
	## THERE IS NO `nonlocal` HERE, ONLY INSIDE THE CLOSURE
	
	# Closure definition
	@AbstractClosure
	def setterClosure(value):
		nonlocal name, env
		...
	
```
    3. Use the defined closure under name `setterClosure`.

  A function that is defined at top level (not inside other function) must not have `nonlocal` identifiers.
  Normal (non-inner) functions never have a `nonlocal` clause. Only a function inside a function may have `nonlocal` variables.
  
  When making the function `CreateArrayIterator` start it like that:
```
def CreateArrayIterator(array: Object, kind: Constant[{Constant.key_value, Constant.key, Constant.value}]) -> Generator:
	# No `nonlocal` here.
	
	@AbstractClosure
	def closure():
		nonlocal kind, array
		...
```

  In order to assert if function "`IsPropertyReference` ( `V` )" is true, use `assert IsPropertyReference(V)`.

  Whenever the specification says to throw an exception SOME_ERROR, return `ThrowCompletion(Error["SOME_ERROR"]("MESSAGE"))`.
  Convert SOME_ERROR to camel case, i.e. when SOME_ERROR is `"Typeerror"` convert it to `"TypeError"`. SOME_ERROR is a string, so put it in quotes.
  The MESSAGE should be a string referencing the name of the function the error happens in, and the condition that caused it.
   I.e. the following spec line "If ERROR_CONDIDION, throw SOME_ERROR" happening inside function FUNC_NAME should result in `return ThrowCompletion(Error["SOME_ERROR"]("Error in FUNC_NAME: ERROR_CONDITION"))`.
  Whenever the specification says to create an Error object instance, add message to the constructor referencing the function name. Convert the error type name to camel case.
   I.e. "a newly created `Typeerror` object" inside a function FUNC_NAME should result in `Error["TypeError"]("Error inside FUNC_NAME")`.

  As a special case, convert the name of function "Set" to `Set_`. But when the spec says to "create a new set" then use constructor `Set` without underscore. `Set_` is a function and `Set` is a type name.
  I.e. use `Set_(globalObj, V.ReferencedName, W, False)`.

  Change the function name `eval` to `eval_`.
  Change the function name `Map` to `Map_`.

  Never use `mode == Constant.async`. Use `mode == Constant.async_` instead.

  The subexpression "&lt;method&gt; `ℝ` ( `t` / &lt;function&gt; `msPerDay` )" means `(t / msPerDay()).MV()`.
 </prompt>

 <prompt context="Syntax Directed Operation">
  <!-- Prompt present in all requests to make a syntax-directed operation. SDOs are methods of the class `ParseNode` and therefore always have `self` argument. -->
  <line context="First match">In case this production matches </line>
  <line context="Next match"> or this production matches </line>
  <line context="Match found">  perform the following steps:</line>
  <line context="No match">Otherwise, in case this production does not match any of the Productions at the beginning, return `NotImplemented` at the end of the function.</line>

  This is a syntax-directed operation. It begins with a match of `self` against one or more Production constants.
  If `self` matches any of the Productions, perform the listed steps that follow.
  If none of the Productions are matched, return `NotImplemented`.

  Insert a line with the comment "# Testing for match..." before the "if" block.
  Insert a line with the comment "# Match found" inside the "if" block.

  So the whole function should follow the pattern:
```
def METHOD_NAME(self:Self, ARGS):
	# Testing for match...

	if self.matches(Production(SOMETHING1)) or \
		self.matches(Production(SOMETHING2)):

		# Match found

		PERFORM_STEP_1
		PERFORM_STEP_2

		...
	else:
		return NotImplemented
```

  Whenever the specification says "this production", take it as `self`. "This production" always refers to the `self` argument.
  To check if this production matches a `Production(...)` object, use `self.matches(Production(...))`.

  When comparing a string with a `Nonterminal`, use `javascript_grammar.matches(STRING, NONTERMINAL)`.
  When comparing a `Terminal` with a `Nonterminal`, use `javascript_grammar.matches(TERMINAL.value, NONTERMINAL)`.
  When the specification says "`StringValue` of XXX is a Nonterminal('ReservedWord')", use `lexical_grammar.matches(XXX.StringValue(), Nonterminal('ReservedWord'))`.
  When comparing two `Nonterminal`s, use comparison operator: `NONTERMINAL1 == NONTERMINAL2`;

  Whenever the specification says that some non-string object X "is" a Nonterminal YYY, take it as `X.matches(Nonterminal('YYY'))`.
  Whenever the specification says that some non-string object X "is matched by" a Nonterminal YYY, take it as `X.matches(Nonterminal('YYY'))`.

  When other rules don't apply, take "Nonterminal('NAME')" as `self.get_subtree(Nonterminal('NAME'))`.
  When other rules don't apply, take "Nth Nonterminal('NAME')" as `self.get_subtree(Nonterminal('NAME'), N)` where N is the number starting from 1. "First" means 1, "second" means 2, etc.
  When other rules don't apply, take "this Nonterminal('NAME')" as `self.get_subtree(Nonterminal('NAME'), 0)`.
  When other rules don't apply, take "a Nonterminal('NAME1') that is covered by Nonterminal('NAME2')" as `self.get_subtree(Nonterminal('NAME2')).get_subtree(Nonterminal('NAME1'))`.

  Whenever the specification says "&lt;method&gt; `METHOD` of Nonterminal('NAME')" possibly with arguments ARGS, take it as `SUBTREE.METHOD(ARGS)` where SUBTREE is an object obtained through `self.get_subtree(...)` as in one of the rules above.
  Whenever the specification says "( [ PARAM ] ) parameter was set" or "this production has ( [ PARAM ] ) parameter", take it as `self.has_param(PARAM)`.
  To check if a "Nonterminal('NAME') is present", use `self.has_subtree(Nonterminal('NAME'))`.
  To obtain source text of some object, use method `source()`.
  To get all items matching Nonterminal('AAA') contained within Nonterminal('BBB'), use iteration: `for item in self.get_subtree(Nonterminal('BBB')).get_all_subtrees(Nonterminal('AAA'))`

  Whenever the specification says "“COLUMN_NAME” column of Table NUMBER", take it as `Table_NUMBER`. Such tables contain lists of properties. To check if a VALUE matches them iterate like `any(VALUE.matches(_property["COLUMN_NAME"]) for _property in Table_NUMBER)`.
  When the spec says about "Table 66" just iterate over `[_row[COLUMN_NAME] for _row in Table_66]`.
  When the spec says about "Table 67" just iterate over `[_row[COLUMN_NAME] for _row in Table_67]`.

  When the spec says "Return &lt;return_if_abrupt&gt; &lt;method&gt; `LabelledEvaluation` of this Nonterminal('BreakableStatement') with argument `newLabelSet` ." it should result in:
```
	return self.get_subtree(Nonterminal('BreakableStatement'), 0).LabelledEvaluation(newLabelSet)
```
  When the spec says "&lt;method&gt; `LabelledEvaluation` of this Nonterminal('LabelledStatement') with argument « » ." it should give: `self.get_subtree(Nonterminal('LabelledStatement'), 0).LabelledEvaluation([])`.
 </prompt>

 <prompt context="Early Errors">
  <!--
   Prompt present in all requests to make an "early errors" sub-procedure (a syntax-directed operation). These methods have `self` and `goal` arguments.
   If the `self` parse node does not match any production, it should return `NotImplemented`.
  -->
  This function returns List of Errors or `NotImplemented`.
  The `goal` argument is of type Nonterminal.

  If `self` matches any of the Productions, first create a list `errors`, then run the steps as in the specification, then return `errors`.

  The whole function should follow the pattern:
```
def _early_errors(self:Self, goal:Nonterminal) -> List[Error["SyntaxError"]]:
	# Testing for match...

	if self.matches(Production(SOMETHING1)) or \
		self.matches(Production(SOMETHING2)):

		# Match found
		
		errors = [] # create the list with SyntaxErrors
		
		# Run the steps as in specification
		PERFORM_STEP_1
		PERFORM_STEP_2
		...
		
		return errors # return the list of SyntaxErrors
	else:
		return NotImplemented
```

  To check if a VALUE is some Unicode code point matched by the Nonterminal('XXX') lexical grammar production, use `lexical_grammar.matches(chr(VALUE), Nonterminal('XXX'))`.
  To check if a character value VALUE is the numeric value of some code point matched by the Nonterminal('NONTERMINAL') lexical grammar production, use `lexical_grammar.matches(chr(VALUE), Nonterminal('XXX'))`.
  To check if a goal symbol of the syntactic grammar is some nonterminal, compare the `goal` argument with the nonterminal using equality operator `==`.
  Whenever the specification says "It is a Syntax Error if ...", test if the condition is met and append `Error["SyntaxError"]("SPEC_LINE")` to `errors` if so. Put the error specification as SPEC_LINE, starting from "It is a Syntax Error...". Escape quote characters inside the string.
  I.e. "It is a Syntax Error if &lt;function&gt; `IsStrict` ( this production ) is true and the &lt;method&gt; `StringValue` of `Identifier` is either 'arguments' or 'eval' ." should give:
```
if IsStrict(self) or Identifier.StringValue() in ["arguments", "eval"]:
	errors.append(Error["SyntaxError"]("It is a Syntax Error if &lt;function&gt; `IsStrict` ( this production ) is true and the &lt;method&gt; `StringValue` of `Identifier` is either 'arguments' or 'eval' ."))
```
  Likewise: "It is a Syntax Error if &lt;method&gt; `HasDirectSuper` of Nonterminal('GeneratorMethod') is true ." should give:
```
if self.get_subtree(Nonterminal('GeneratorMethod')).HasDirectSuper():
	errors.append(Error["SyntaxError"]("It is a Syntax Error if &lt;method&gt; `HasDirectSuper` of Nonterminal('GeneratorMethod') is true ."))
```

  The phrase "any source text is matched by this production" always evaluates to true.
  To check if the source text is being processed by a direct eval use `execution_context_stack[-1].is_direct_eval()`.

  To check if any element of COLLECTION_A also occurs in COLLECTION_B convert them to sets and check if their intersection is not empty: `if set(COLLECTION_A) &amp; set(COLLECTION_B): ...`.
 </prompt>

 <prompt context="Evaluation">
  <!--
   Prompt present in all requests to make an "Evaluation" sub-procedure (a syntax-directed operation). These methods have `self` argument.
   If the `self` parse node does not match any production, it should return `NotImplemented`.
  -->
  To check if debugging is enabled, call `is_debug_enabled()`.
  To perform an implementation-defined debugging action, call the function `debug` (like: `result = debug()`) and then return the completion record `Completion(result)`.

  Never return `CompletionRecord(Type=Constant.normal, Value=NotImplemented)`, just return `NotImplemented`.
 </prompt>

 <function name="ParseText">
  To parse a list of code points against a certain goal, use `javascript_grammar.parse(source, goal)`. This method returns a `ParseNode` or `None`.
  If it returned `None`, that means the source text is not well formed. In that case, return `[Error["SyntaxError"]("Source text not well-formed.")]`. Insert a comment "source text failure". Assert that the returned value was `None`.
  Otherwise, call the method `early_errors` on the ParseNode.
  If the list of errors is empty, it means success and in that case return the ParseNode. Insert a comment "success"
  If the list of errors is not empty, return it and end the function. Insert a comment "early_errors failure".
 </function>

 <function name="YearFromTime">
  Do not make a closure. Start with year = 0 and iterate in a `while` loop to find the largest number as described in spec. Assert that the returned value is smaller or equal to the requested parameter.
 </function>

</codegen>
